@charset "UTF-8";
.header {
  color: red;
}
.header .header_parent {
  color: orange;
}
.header .header_parent .header_child1 {
  color: yellow;
}
.header .header_parent .header_child1 .header_child2 {
  color: blue;
}

.border {
  background-color: black;
}
.border_copy {
  color: white;
}

button {
  color: blue;
}
button:hover {
  opacity: 0.5;
}
button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}
button.isLoading {
  color: green;
}
button + button {
  margin-top: 10px;
}

.hello span {
  color: blue;
}
.hellospan {
  color: green;
}
.hello.span {
  color: purple;
}

.underscore {
  font-size: 200px;
}

.hypen {
  font-size: 200px;
}

.main {
  width: 100rem;
}

/**
 컴파일 결과
 main { width: 100pxrem; }
 .footer { //에러 }
*/
/*
 출력결과:
 .hello {
   background-image: url("/images/Nana.png");
 }
*/
/**
CSS 파일은 누구나 뜯어볼 수 있기 때문에 비밀스러운(?) 주석을 다는 것이 불가능합니다.
개발하다보면 개발에만 필요한 주석을 달아야할 때가 있는데 말이죠. 
이런 불편함을 해소하고자 Sass에서는 //형태로 인라인 주석을 사용할 수 있습니다. 
인라인 주석은 어디든 끼워넣을 수 있고, 컴파일 과정에서 뿅 사라집니다.
*/
h1 {
  color: #fff;
  background-color: yellow;
}

h1 {
  color: #000;
  background-color: #fff;
}

/**
믹스인은 최상위 문(Top-Level Statements)이므로, 스타일시트의 최상위 레벨에서 사용합니다. 
그렇다는 건 최상위 문이 아닌 다른 문을 믹스인 속에 포함시켜 쓸 수 있다는 거죠! 
버튼을 어떤 곳에서는 네모나게 쓰고, 어떤 곳에서는 동그랗게 써야 하는 상황일 때,
radius 값이 인자로 넘어온 경우에만 border-radius 속성을 적용하는 예시입니다.
*/
.btn-square {
  width: 100px;
  height: 100px;
}

.btn-circle {
  width: 100px;
  height: 100px;
  border-radius: 50%;
}

/**
믹스인에 내용 덧붙이기
@content 구문을 쓰면 @include로 불러와 쓸 때 내용을 추가로 입력할 수 있습니다.
*/
button:hover {
  font-weight: bold;
  color: red;
}
button.on {
  color: red;
}

/*
 * 출력결과:

 button:hover {
   font-weight: bold;
   color: red;
 }

 button.on {
   color: red;
 }
*/
.title {
  font-size: 16px;
}
@media screen and (min-width: 768px) {
  .title {
    font-size: 14px;
  }
}
@media screen and (max-width: 540px) {
  .title {
    font-size: 12px;
  }
}

/*
    * 출력:

    .title {
      font-size: 16px;
    }

    @media screen and (min-width: 768px) {
      .title {
        font-size: 14px;
      }
    }

    @media screen and (max-width: 540px) {
      .title {
        font-size: 12px;
      }
    }
  */
/**
접근성을 위한 대체 텍스트 표시와 말줄임 처리를 위한 속성입니다.
요 두 개는 프로젝트를 할 때마다 기본 아이템처럼 만들고 시작하는 편이에요✌️
  */
/**
이번엔 @extend를 살펴봅니다. 이건 말그대로 '확장'으로, 기본 내용에서 뭔가를 덧붙일 때 사용해요!
사용법은 이미 존재하는 셀렉터를 @extend로 지정해주면 됩니다.
예를 들어 모든 버튼은 폰트가 굵고 보더가 있지만 클래스에 따라 보더 색상이 다른 상황입니다.
그러면 공통되는 부분(폰트굵게+보더있음)을 먼저 선언하고 @extend로 공통 스타일을 상속받습니다.
*/
.button, .button-error, .button-confirm {
  font-weight: bold;
  border-width: 1px;
}

.button-confirm {
  border-color: blue;
}

.button-error {
  border-color: red;
}

/**
익스텐드는 확장시킬 '기본 스타일 선언'이 필요합니다. 그렇다는 건 이 스타일은 컴파일이 됩니다.
하지만 오로지 확장만을 위해 스타일을 선언하고 싶다면 % 기호를 사용할 수 있어요.
%가 포함된 셀렉터는 오로지 @extend로 불러와 쓰기 위해 사용되며 컴파일된 CSS에 포함되지 않습니다.
*/
.title-sub, .title-main {
  color: blue;
  font-weight: bold;
}

.title-main {
  font-size: 30px;
}

.title-sub {
  font-size: 18px;
}

/** 
mixin VS extend

@mixin
- 인자를 넣을 수 있어요.
- 선택자 관리가 쉬워서 전역으로 쓰기 편해요.
- 컴파일된 CSS가 길어져요.

@extend
- 연관성 있는 셀렉터들을 묶어 관리할 수 있어요.
- 미디어쿼리 등으로 셀렉터가 묶일 수 없다면 쓸 수 없어요.

@mixin: 미리 정의한 속성을 복사해서 따로 적용
@extend: 선택자를 함께 묶어 속성을 한번에 적용

선택자끼리 의미론적 관계가 있다면 @extend를, 
그렇지 않고 단순히 속성만 겹치는 관계라면 @mixin을 쓰는 것을 추천합니다. 
*//*# sourceMappingURL=test.css.map */